# 文字列 - Haskell レシピ集

文字や文字列の処理を扱います。

目次(予定)

- [ ] (XMLを解析する)
- [ ] (YAMLを解析する)
- [ ] (いろいろなテキストフォーマットを解析する)
- [ ] (インデントを変更する)
- [x] [タブと半角空白文字を変換する](タブと半角空白文字を変換する.md)
- [ ] ヒアドキュメントを使う
- [ ] (メッセージダイジェストを作成する)
- [ ] (空白にマッチさせる)
- [ ] (行末の改行文字を取り除く)
- [ ] 正規表現が文字列の先頭・末尾にマッチするか調べる
- [ ] 正規表現で文字列を分割する
- [ ] 正規表現にマッチした部分の前後の文字列を取り出す
- [ ] 正規表現にマッチした部分を取り出す
- [ ] (正規表現のドットに改行をマッチさせる)
- [ ] (前回マッチした部分の続きからマッチさせる)
- [ ] (単語にマッチさせる)
- [x] [特定の文字・文字列の出現回数を調べる](特定の文字・文字列の出現回数を調べる.md)
- [ ] (特定の文字コードで正規表現マッチを行う)
- [x] [文字が大文字か小文字かを調べる](文字が大文字か小文字かを調べる.md)
- [x] [文字と文字コードを相互変換する](文字と文字コードを相互変換する.md)
- [x] [文字の出現頻度を調べる](文字の出現頻度を調べる.md)
- [x] [文字を大文字・小文字に変換する](文字を大文字・小文字に変換する.md)
- [x] [文字コードを変換する](文字コードを変換する.md)
- [x] [テキストデータのエンコーディング方式を推測する](テキストデータの文字エンコーディング方式を推測する.md)
- [x] [文字列が空行か調べる](文字列が空行か調べる.md)
- [x] [文字列が数値を表すか判定する](文字列が数値を表すか判定する.md)
- [x] [文字列が表す数値を得る](文字列が表す数値を得る.md)
- [ ] 文字列が複数の正規表現のすべてにマッチするか調べる
- [ ] 文字列の一部を取り出す
- [ ] 文字列の一部を取り除く
- [ ] 文字列の一部を置換する
- [ ] 文字列の一部を特定の文字で埋める
- [x] [文字列の先頭・末尾から空白を取り除く](文字列の先頭・末尾から空白を取り除く.md)
- [x] [文字列に含まれる文字数を得る](文字列に含まれる文字数を得る.md)
- [ ] (文字列の末尾に文字列を追加する)
- [ ] 文字列をn文字ずつに分割する
- [ ] 文字列を検索する
- [ ] 文字列を行に分ける
- [ ] (文字列を最大nバイトに切り詰める)
- [ ] 文字列を最大n文字に切り詰める
- [ ] 文字列を単語に分ける
- [x] [文字列を反復する](文字列を反復する.md)
- [x] [文字列を比較する](文字列を比較する.md)
- [ ] 文字列を連結する

## 文字列の表現

文字列を表す型は``String``は文字を表す型の値を要素とするリストとして表現するのが一般的でした．
標準``Prelude``モジュールでは，

```haskell
type String = [Char]
```

と定義されています．
``String``を使う利点は，リスト上の多相関数であれば ``String`` の対する関数としてそのまま使えることが多いことです．

しかし，最近では，主に入出力における性能改善のために，GHC では``String``型の代りに``Text``型を使うことも多くなりました．
このレシピでは``Text``を使う場合と``String``を使う場合とをともに示すことにします．

## ``Text`` を使うときの一般的な設定

``Text``型とその上の便利なライブラリ関数を提供するモジュールは[``text``パッケージ](http://hackage.haskell.org/package/text)で提供されています．
``Text``型を使う場合にはモジュールファイルの先頭に言語拡張``OverloadedString``を指定しておくと，文字列リテラルを``Text``型に対しても使えるので便利です．
また，``text``パッケージが提供するAPIには，標準``Prelude``が提供するAPIと同名のものが多くあるので衝突を避けるために，修飾付きの名前を使うようにすると良いでしょう．

```haskell
{-# LANGUAGE OverloadedStrings #-}
module Foo where

import Data.Char
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T

main :: IO () 
main = T.interact (T.unlines . map foo . T.lines)

foo :: Text -> Text
foo = const "あらそうですか．"
```

## 日本語の文字列を扱う

Haskellでは文字を表す型は``Char``型です．
文字に関する関数の多くは``Data.Char``モジュールで定義されています．
Haskellは文字としてUnicode文字集合を使います．
``Char``は内部的には，UTF-32でエンコードされたUnicode文字に対応しています．

GHCでは受け入れ可能なプログラムはUTF-8でエンコードされているテキストです．
プログラムで文字列リテラルやコメントで日本語の文字列を含めるときは，UTF-8でエンコードしたテキストファイルにする必要があります．

UTF-8でエンコーディングされているテキストは通常のUTF-8以外でエンコーディングされているテキストデータを扱う場合には変換が必要になります．
